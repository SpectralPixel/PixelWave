using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;

public class ColumnDataGenerator
{

    public class ColumnGenData
    {
        public System.Action<int[,]> OnComplete;
        public Vector2Int GenerationPoint;
    }

    private WorldGenerator generatorInstance;
    private Queue<ColumnGenData> dataToGenerate;
    private int chunkColumnsGenerating = 0;
    private int parallelGenerationCap;
    public bool Terminate;

    public ColumnDataGenerator(WorldGenerator _worldGenerator)
    {
        generatorInstance = _worldGenerator;
        parallelGenerationCap = generatorInstance.ParallelGenerationCap;
        dataToGenerate = new Queue<ColumnGenData>();

        _worldGenerator.StartCoroutine(DataGenLoop());
    }

    public void QueueColumnToGenerate(ColumnGenData data)
    {
        dataToGenerate.Enqueue(data);
    }

    public IEnumerator DataGenLoop()
    {
        while (!Terminate)
        {
            if (dataToGenerate.Count > 0 && chunkColumnsGenerating < parallelGenerationCap)
            {
                ColumnGenData data = dataToGenerate.Dequeue();
                generatorInstance.StartCoroutine(GenerateColumnData(data.GenerationPoint, data.OnComplete));
                chunkColumnsGenerating++;
                yield return new WaitUntil(() => data.OnComplete != null);
                chunkColumnsGenerating--;
            }

            yield return null;
        }
    }

    public IEnumerator GenerateColumnData(Vector2Int _columnPosition, System.Action<int[,]> _callback)
    {
        int _blocksPerChunk = WorldGenerator.BlocksPerChunk;
        int _verticesPerChunk = _blocksPerChunk + 1;
        int _perlinOctaves = 3;

        Vector2 noiseOffset = generatorInstance.noiseOffset;
        Vector2 noiseScale = generatorInstance.noiseScale;
        float heightIntensity = generatorInstance.heightIntensity;
        int terrainOffset = generatorInstance.terrainOffset;

        int[,] _groundHeights = new int[_verticesPerChunk, _verticesPerChunk];

        Task _task = Task.Factory.StartNew(delegate
        {
            for (int x = 0; x <= _blocksPerChunk; x++)
            {
                for (int z = 0; z <= _blocksPerChunk; z++)
                {
                    float _groundHeight = terrainOffset; // gets a height to start generating at with perlin noise
                    for (int octave = 1; octave <= _perlinOctaves; octave++)
                    {
                        int octave2 = octave * octave;
                        float _perlinCoordX = ((noiseOffset.x + 10) * octave2) + (x + (_columnPosition.x * _blocksPerChunk)) / (_blocksPerChunk * (noiseScale.x / octave2)); // gets X coordinate for perlin noise function
                        float _perlinCoordZ = ((noiseOffset.y + 10) * octave2) + (z + (_columnPosition.y * _blocksPerChunk)) / (_blocksPerChunk * (noiseScale.y / octave2));

                        _groundHeight += (Mathf.PerlinNoise(_perlinCoordX, _perlinCoordZ) - 0.5f) * (heightIntensity / octave2);
                    }

                    Vector2Int _worldPosition = LocalToWorldPosition(new Vector2Int(x, z), _columnPosition, _blocksPerChunk);
                    float _distanceToOrigin = Pythagoras(_worldPosition.x, _worldPosition.y);
                    float _heightFalloff = ((_distanceToOrigin * _distanceToOrigin) / 5000) - 50; // use desmos, gives nice visual representation of falloff
                    if (_heightFalloff < 0) _heightFalloff = 0;
                    _groundHeight -= _heightFalloff;

                    _groundHeights[x, z] = Mathf.RoundToInt(_groundHeight);
                }
            }
        });

        yield return new WaitUntil(() =>
        {
            return _task.IsCompleted;
        });

        if (_task.Exception != null) Debug.LogError(_task.Exception);

        //WorldChunkColumns.Add(_columnPosition, _groundHeights);
        WorldGenerator.WorldChunkColumns[_columnPosition] = _groundHeights; //// temporary fix, column still being generated by all of the new chunks in a column
        _callback(_groundHeights);
    }

    float Pythagoras(float a, float b)
    {
        return Mathf.Sqrt(a * a + b * b);
    }

    Vector2Int LocalToWorldPosition(Vector2Int _localPosition, Vector2Int _chunkPosition, int _chunkSize)
    {
        int _globalXPosition = (_chunkPosition.x * _chunkSize) + _localPosition.x;
        int _globalYPosition = (_chunkPosition.y * _chunkSize) + _localPosition.y;
        return new Vector2Int(_globalXPosition, _globalYPosition);
    }
}
