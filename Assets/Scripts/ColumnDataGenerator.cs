using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;

public class ColumnDataGenerator
{

    public class ColumnGenData
    {
        public System.Action<int[,]> OnComplete;
        public Vector2Int GenerationPoint;
    }

    private WorldGenerator generatorInstance;
    private Queue<ColumnGenData> dataToGenerate;
    private int chunkColumnsGenerating = 0;
    private int parallelGenerationCap;
    public bool Terminate;

    public ColumnDataGenerator(WorldGenerator _worldGenerator)
    {
        generatorInstance = _worldGenerator;
        parallelGenerationCap = generatorInstance.ParallelGenerationCap;
        dataToGenerate = new Queue<ColumnGenData>();

        _worldGenerator.StartCoroutine(DataGenLoop());
    }

    public void QueueColumnToGenerate(ColumnGenData data)
    {
        dataToGenerate.Enqueue(data);
    }

    public IEnumerator DataGenLoop()
    {
        while (!Terminate)
        {
            if (dataToGenerate.Count > 0 && chunkColumnsGenerating < parallelGenerationCap)
            {
                ColumnGenData data = dataToGenerate.Dequeue();
                generatorInstance.StartCoroutine(GenerateColumnData(data.GenerationPoint, data.OnComplete));
                chunkColumnsGenerating++;
                yield return new WaitUntil(() => data.OnComplete != null);
                chunkColumnsGenerating--;
            }

            yield return null;
        }
    }

    public IEnumerator GenerateColumnData(Vector2Int _columnPosition, System.Action<int[,]> _callback)
    {
        int _blocksPerChunk = WorldGenerator.BlocksPerChunk;
        int _verticesPerChunk = _blocksPerChunk + 1;

        Vector2 noiseOffset = generatorInstance.noiseOffset;
        Vector2 noiseScale = generatorInstance.noiseScale;
        float heightIntensity = generatorInstance.heightIntensity;
        int terrainOffset = generatorInstance.terrainOffset;

        int[,] _groundHeights = new int[_verticesPerChunk, _verticesPerChunk];

        Task _task = Task.Factory.StartNew(delegate
        {
            for (int x = 0; x <= _blocksPerChunk; x++)
            {
                for (int z = 0; z <= _blocksPerChunk; z++)
                {
                    float _perlinCoordX = noiseOffset.x + (x + (_columnPosition.x * 16f)) / _blocksPerChunk * noiseScale.x; // gets X coordinate for perlin noise function
                    float _perlinCoordZ = noiseOffset.y + (z + (_columnPosition.y * 16f)) / _blocksPerChunk * noiseScale.y;
                    int _groundHeight = Mathf.RoundToInt(Mathf.PerlinNoise(_perlinCoordX, _perlinCoordZ) * heightIntensity + terrainOffset); // gets a height to start generating at with perlin noise
                    _groundHeights[x, z] = _groundHeight;
                }
            }
        });

        yield return new WaitUntil(() =>
        {
            return _task.IsCompleted;
        });

        if (_task.Exception != null) Debug.LogError(_task.Exception);

        //WorldChunkColumns.Add(_columnPosition, _groundHeights);
        WorldGenerator.WorldChunkColumns[_columnPosition] = _groundHeights; //// temporary fix, column still being generated by all of the new chunks in a column
        _callback(_groundHeights);
    }
}
