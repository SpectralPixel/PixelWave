using System.Collections;
using System.Collections.Generic;
using System.Threading.Tasks;
using UnityEngine;

public class WorldGenerator : MonoBehaviour
{

    public static WorldGenerator Instance;
    public static Dictionary<Vector3Int, WorldChunk> WorldChunks;
    public static Dictionary<Vector2Int, int[,]> WorldChunkColumns;
    public static Dictionary<Vector3Int, GameObject> ActiveChunks;

    static readonly public int BlocksPerChunk = 16;
    [Space]
    public Vector2 noiseScale;
    public Vector2 noiseOffset;
    public float heightIntensity;
    public int worldHeight;
    [Space]
    [SerializeField] private Material meshMaterial;

    [HideInInspector] public int VertecesPerChunk; // BlocksPerChunk + 1

    [SerializeField] private TextureLoader TextureLoaderInstance;
    private MeshGenerator meshCreator;


    void Awake()
    {
        Instance = this;
    }

    void Start()
    {
        WorldChunks = new Dictionary<Vector3Int, WorldChunk>();
        WorldChunkColumns = new Dictionary<Vector2Int, int[,]>();
        ActiveChunks = new Dictionary<Vector3Int, GameObject>();

        meshCreator = new MeshGenerator(TextureLoaderInstance);

        VertecesPerChunk = BlocksPerChunk + 1;
    }

    public IEnumerator CreateNewWorldChunk(Vector3Int _chunkCoord)
    {
        string _newChunkName = $"Chunk {_chunkCoord.x} {_chunkCoord.y} {_chunkCoord.z}";
        GameObject _newChunk = new GameObject(_newChunkName, new System.Type[]
        {
            typeof(MeshRenderer),
            typeof(MeshFilter),
            typeof(MeshCollider)
        });

        _newChunk.transform.position = new Vector3(_chunkCoord.x * BlocksPerChunk, _chunkCoord.y * BlocksPerChunk, _chunkCoord.z * BlocksPerChunk);
        ActiveChunks.Add(_chunkCoord, _newChunk);

        // a column is used to store data on where the ground should start
        Vector2Int _worldColumnPosition = new Vector2Int(_chunkCoord.x, _chunkCoord.z);
        int[,] _newHeightData = WorldChunkColumns.ContainsKey(_worldColumnPosition) ? WorldChunkColumns[_worldColumnPosition] : null;
        if (_newHeightData == null) // checks if _newHeightData is null (meaning it doesn't exist yet)
        {
            StartCoroutine(GenerateColumnData(_worldColumnPosition, callback => _newHeightData = callback)); // starts a couroutine with a callback that will set _newHeightData to it's value
            yield return new WaitUntil(() => _newHeightData != null); // waits until _newHeightData is not null (meaning the column data has been generated by the coroutine)
        }

        // if the chunk already exists in WorldChunks, load it. Otherwise generate it
        WorldChunk _newChunkData = WorldChunks.ContainsKey(_chunkCoord) ? WorldChunks[_chunkCoord] : null;
        if (_newChunkData == null)
        {
            StartCoroutine(GenerateWorldChunk(_chunkCoord, _newHeightData, callback => _newChunkData = callback));
            yield return new WaitUntil(() => _newChunkData != null);
        }

        Mesh _newChunkMesh = null;

        StartCoroutine(meshCreator.CreateNewMesh(_newChunkData, callback => _newChunkMesh = callback));
        yield return new WaitUntil(() => _newChunkMesh != null);

        if (_newChunk != null)
        {
            MeshFilter _newChunkFilter = _newChunk.GetComponent<MeshFilter>();
            _newChunkFilter.mesh = _newChunkMesh;

            MeshRenderer _newChunkRenderer = _newChunk.GetComponent<MeshRenderer>();
            _newChunkRenderer.material = meshMaterial;

            MeshCollider _newChunkCollider = _newChunk.GetComponent<MeshCollider>();
            _newChunkCollider.sharedMesh = _newChunkFilter.mesh;
        }
    }

    IEnumerator GenerateColumnData(Vector2Int _columnPosition, System.Action<int[,]> _callback)
    {
        int[,] _groundHeights = new int[BlocksPerChunk, BlocksPerChunk];

        Task _task = Task.Factory.StartNew(delegate
        {
            for (int x = 0; x < BlocksPerChunk; x++)
            {
                for (int z = 0; z < BlocksPerChunk; z++)
                {
                    float _perlinCoordX = noiseOffset.x + (x + (_columnPosition.x * BlocksPerChunk)) / BlocksPerChunk * noiseScale.x; // gets X coordinate for perlin noise function
                    float _perlinCoordZ = noiseOffset.y + (z + (_columnPosition.y * BlocksPerChunk)) / BlocksPerChunk * noiseScale.y;
                    int _groundHeight = Mathf.RoundToInt(Mathf.PerlinNoise(_perlinCoordX, _perlinCoordZ) * heightIntensity + worldHeight); // gets a height to start generating at with perlin noise
                    _groundHeights[x, z] = _groundHeight;
                }
            }
        }); // C# task now handles column creation

        yield return new WaitUntil(() =>
        {
            return _task.IsCompleted;
        }); // waits until the task is completed

        if (_task.Exception != null) Debug.LogError(_task.Exception);

        WorldChunkColumns.Add(_columnPosition, _groundHeights);
        _callback(_groundHeights); // use callback instead of return
    }

    IEnumerator GenerateWorldChunk(Vector3Int _chunkPosition, int[,] _groundHeights, System.Action<WorldChunk> _callback)
    {
        Block[,,] _newChunkData = new Block[VertecesPerChunk, VertecesPerChunk, VertecesPerChunk]; // to the power of 3 because 3-dimensional

        Task _task = Task.Factory.StartNew(delegate
        {
            for (int x = 0; x <= BlocksPerChunk; x++)
            {
                for (int y = 0; y <= BlocksPerChunk; y++)
                {
                    for (int z = 0; z <= BlocksPerChunk; z++)
                    {
                        int _groundHeight = LocalToWorldHeight(_groundHeights[x, z], _chunkPosition);
                        int _minimumHeight = LocalToWorldHeight(-worldHeight, _chunkPosition);
                        int _blockTypeToAssign = 0;

                        // create grass if at the top layer
                        if (y == _groundHeight) _blockTypeToAssign = 5;

                        // next 3 blocks dirt
                        if (y < _groundHeight && y > _groundHeight - 4) _blockTypeToAssign = 2;

                        // everything between dirt range (inclusive) and and 0 (exclusive) is stone
                        if (y <= _groundHeight - 4 && y > _minimumHeight) _blockTypeToAssign = 3;

                        // height 0 is bedrock
                        if (y == _minimumHeight) _blockTypeToAssign = 4;

                        _newChunkData[x, y, z] = new Block(_blockTypeToAssign, new Vector3Int(x, y, z));
                        if (y > BlocksPerChunk) _newChunkData[x, y, z] = new Block(_blockTypeToAssign, new Vector3Int(x, y, z));
                    }
                }
            }
        });

        yield return new WaitUntil(() =>
        {
            return _task.IsCompleted;
        });

        if (_task.Exception != null) Debug.LogError(_task.Exception);

        WorldChunk _newChunk = new WorldChunk(_chunkPosition, BlocksPerChunk, _newChunkData);
        WorldChunks.Add(_chunkPosition, _newChunk);
        _callback(_newChunk);
    }

    Vector3Int LocalToWorldPosition(Vector3Int _localPosition, Vector3Int _chunkPosition)
    {
        int _globalXPosition = (_chunkPosition.x * BlocksPerChunk) + _localPosition.x;
        int _globalYPosition = (_chunkPosition.y * BlocksPerChunk) + _localPosition.y;
        int _globalZPosition = (_chunkPosition.z * BlocksPerChunk) + _localPosition.z;
        return new Vector3Int(_globalXPosition, _globalYPosition, _globalZPosition);
    }

    int LocalToWorldHeight(int _localHeight, Vector3Int _chunkPosition)
    {
        int _globalHeight = (-_chunkPosition.y * BlocksPerChunk) + _localHeight;
        return _globalHeight;
    }
}
